#include "motor.hpp"

struct PropParam {
    double R = 0.064; //Radius of the propeller, default is 5x4.92-inch propeller
    double C_T = 0.14; //Coeff for thrust
    double C_Q = 0.15/6.28; //Coeff for torque
    MotorParam motor_param;
    double inflow_speed = 0; //Speed of inflow air.
    int clockwise = 1; //See from top. if counter-clockwise, then -1
    double Irotorhead = 0.000118500; 
    ActuatorParam aparam;
};

class Propeller : public Actuator {
    Motor motor;
    PropParam param;
    EnvironmentParam eparam;

public:
    Propeller(PropParam _param):
        Actuator(_param.aparam),
        param(_param),motor(_param.motor_param)
    {
    }

    void operator() (const KinematicsState & kstate, const Eigen::VectorXd &x, Eigen::VectorXd &dxdt) const override {
        Eigen::VectorXd motor_dxdt(MOTOR_STATE_DIM);
        motor(kstate, x.segment<MOTOR_STATE_DIM>(0), 
            motor_dxdt);
        dxdt.segment<MOTOR_STATE_DIM>(0) = motor_dxdt;
    }
    
    inline double thrust(double rpm_cur) const {
        double CT = param.C_T;
        double rho = eparam.rho;
        double n = rpm2rps(rpm_cur);

        return CT*rho*n*n*pow(diameter(), 4);
    }
    
    //FLU, propeller default generate forces at x axis.
    Eigen::Vector3d get_force(const KinematicsState & kstate, const Eigen::VectorXd &x) const {
        double rpm_cur = x(0);
        double T = thrust(rpm_cur);
        return Eigen::Vector3d(T, 0, 0);
    }

    Eigen::Vector3d get_torque(const KinematicsState & kstate, const Eigen::VectorXd &x) const {
        double rpm_cur = x(0);
        double T = thrust(rpm_cur);
        
        double CQ = param.C_Q;
        double rho = eparam.rho;
        double n = rpm2rps(rpm_cur);
        double Q = CQ*rho*n*n*pow(diameter(),5)*param.clockwise; //Torque from rotor generated by drag.

        Eigen::VectorXd motor_dxdt(MOTOR_STATE_DIM);
        motor(kstate, x.segment<MOTOR_STATE_DIM>(0), motor_dxdt);

         //Torque from rotor generated by angular acceleration. Not motor dstate/dt is RPM/s, but we need rad/s
        Q = Q + motor_dxdt(0)*rpm2radps(param.Irotorhead)*param.clockwise;
        Eigen::Vector3d torque(Q, 0, 0);
        return torque;
    }

    void set_state(const Eigen::VectorXd &x) override {
        motor.set_state(x.segment<MOTOR_STATE_DIM>(0));
    }

    inline double diameter() const {
        return 2*param.R;
    }

    int get_state_dim()  const override {
        return motor.get_state_dim();
    }

    int get_control_dim()  const override {
        return 1;
    }

    virtual int print_controls(int start_index) const override {
        printf("CTRL AXIS %d: Propeller Throttle\n", start_index);
        return start_index + 1;
    }

    virtual int print_states(int start_index) const override {
        printf("STATE AXIS %d: Propeller RPM  %.2f\n", start_index, motor.get_state()(0));
        return start_index + 1;
    }

    int set_controls(const Eigen::VectorXd& input) override {
        // Throttle
        motor.set_controls(input.segment<1>(0));
        return 1;
    }

    virtual Eigen::VectorXd get_state() const override {
        return motor.get_state();
    }

};
